# Работа с брокером сообщений RabbitMQ на C++
### Использовалась библиотека librabbitmq для работы с RabbitMQ. 
### Разработан сервер, который получает запрос клиента через брокер и отвечает удвоением числа. Настройки хранятся в файле config.ini.
### Разработан клиент c пользовательским интерфейсом для работы c RabbitMQ. Использовался Qt5. Настройки хранятся в файле config.ini и имеют возможность редактирования в GUI.
### Схема взаимодействия клиента и сервера через брокер сообщений: **
### Взаимодействие происходит следующим образом:
#### Клиент при запуске генерирует случайным образом свой ID, состоящий из комбинации цифр и букв длинной от 1 до 10. Далее клиент начинает асинхронно слушать очередь в потоке listenThread класса QueueListener, наследника QThread. Добавлен таймаут на ожидание сообщения в очереди в виде 1 секунды, для того чтобы корректно прерывать работу потока с помощью requestInterruption(). Если не добавить таймаут - поток будет бесконечно слушать очередь и ожидать новых сообщений, что не даёт возможности остановить его в случае изменения настроек, например. При получении сообщения и его парса в объект TestTask::Messages::Response  - срабатывает сигнал messageReceived(), который связан со слотом класса MainWindow - onMessageReceived(). Слот, соответственно, выводит в специальное поле в графическом интерфейсе ответ сервера, т.е удвоенное число.

#### Про отправку сообщений: используя графический интерфейс, пользователь вводит число, которое необходимо удвоить на сервере, нажимает на кнопку "Send", что запускает на клиенте формирование protobuf-сообщения и его отправку в очередь по ключу, заданному в настройках. protobuf-сообщение сериализуется в строку и в таком виде отправляется через брокер.

#### Сервер же постоянно слушает очередь по ключу, заданному в настройках (они должны совпадать в настройках клиента и сервера, т.к иначе запросы клиента не дойдут на сервер, однако это не сломает ни клиент, ни сервер - просто не будет ответа/запроса), при получении сообщения и его парса с помощью ParseFromArray(), сервер формирует ответ, сообщение TestTask::Messages::Response, с помощью функции doubleReq(), которая в свою очередь дополнительно проверяет корректность запроса, а именно ID, т.к у каждого клиента обязательно должен быть ID. В случае отсутствия такового - выбрасывается ошибка std::runtime_error. Если же ответ был успешно сформирован - происходит его сериализация в строку и отправка в очередь по ключу, равному ID запроса, то есть ID клиента.

#### Был выбран тип exchange "Direct Exchange", так как возникла идея отправки ответа с сервера в индивидуальную очередь для каждого клиента, для реализации чего хорошо подходит Direct Exchange, т.к он используется, когда нужно доставить сообщение в определенные очереди. Также, чтобы клиенты не могли "подслушивать" друг друга, было принято решение использовать уникальный идентификатор (ID).
